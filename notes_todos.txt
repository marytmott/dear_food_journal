tests to run:

1. secure backend
	ensure logged in
	ensure correct user


// to dos: 
clean up index.js routes (from app.js)

— error handling on login shit/journal

— finish user crud on front/back ends

*** sample res.son formatted response:
*** item.save(function(err, item) {
    Item.findOne(item).populate('comments.created_by').exec(function (err, item) {
        res.json({
            status: 'success',
            message: "You have commented on this item",
            comment: item.comments.id(comment._id)
        });
    });
});
set expiration time and renewal on web tokens

— need to test typing in routes in url w/ middleware on angular routes

take out console logs

clear blank lines at bottom of files

- web token hash server pw

— clean up super nested routing?

— add token middleware for check tokens on server side to DRY code up

— directives for ng crud forms/updates?

.remove.exec()


need to add resolves to vm.currentuser on loads — page does not load smoothly

put $rootscope.$emit (in users factory) in separate service?

nf_serving_size_qty
nf_serving_size_unit
nf_calories
nf_total_fat
nf_total_carbohydrate
nf_dietary_fiber



* angular scope in directives: 
What we want to be able to do is separate the scope inside a directive from the scope outside, and then map the outer scope to a directive's inner scope. We can do this by creating what we call an isolate scope. To do this, we can use a directive's scope option:
	scope: {
      		customerInfo: '=info'
    	},

Note: These =attr attributes in the scope option of directives are normalized just like directive names. To bind to the attribute in <div bind-to-this="thing">, you'd specify a binding of =bindToThis.


* only providers can go into ng.config()


* note on $q in interceptors————>
http://onehungrymind.com/winning-http-interceptors-angularjs/

Hi Lukas Ruebbelke, great write up and intro to Interceptors. It was a clear way for me to learn something new. However, I would advise that you update the article to explicitly point out the problem when you don’t manually reject the promise in the responseError or requestError handlers for the interceptor (e.g. $q.reject(response)) . Basically causing failed requests (eg. 40x response codes) being handled by the successHandler.


***   db.Post.findByIdAndUpdate(comment.post, {$pull: {comments: comment._id}}, function(err, post) {
    if (err) {
      console.log(err);
    } else {
      console.log(post);
      console.log('DELETED COMMENT REFERENCE FROM ' + post.title);
    }
  });
  next();


***  Animal.remove({zoo: this._id}).exec();
  callback();
});